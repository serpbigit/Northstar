/* --- START OF POLARIS CODEBASE --- */
// DO NOT EDIT THIS FILE DIRECTLY. EDIT THE SOURCE .TS FILES.

// FILE: 01_Config_Global.js
/* --- BLOCK START --- */
"use strict";
/*
 * Contains all global configuration objects and constants for Project Northstar.
 */
// ========== Block#1 — CONFIG ==========
const CFG_ = {
    SETTINGS_SHEET: 'Settings',
    HANDLERS_SHEET: 'Handlers',
    DATAAGENTS_SHEET: 'DataAgents',
    LOG_SHEET: 'Log',
    VERSION: '1.3.0', // Manually update this before each deployment
    DEFAULT_AGENT: 'Default',
};
// Configuration for persistent storage in the PendingActions sheet
const CFG_PENDING_ = {
    SHEET: 'PendingActions',
    HEADERS: ['ActionID', 'Timestamp', 'Status', 'HandlerKey', 'UserID', 'SpaceName', 'ActionPayload']
};
// To make these variables available globally in the Apps Script environment after compilation,
// we attach them to the global scope using 'this'. (GAS V8 compatibility fix)
this.CFG_ = CFG_;
this.CFG_PENDING_ = CFG_PENDING_;
/* --- BLOCK END --- */

// FILE: 02_Utilities.js
/* --- BLOCK START --- */
"use strict";
/*
 * Contains general utility functions for logging, spreadsheet interaction (read/append),
 * and core AI/settings retrieval.
 * (Blocks #2, #3, and #2.1 - NEW)
 */
// ========== Block#1.5 — UTIL: AI Response Parsing ==========
// ========== Block#2 — UTIL: Logging & Sheets ==========
function log_(level, evt, data) {
    try {
        const version = globalThis.CFG_?.VERSION || 'unknown';
        const row = [new Date(), version, level, evt, JSON.stringify(data || {}).slice(0, 3000)];
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, CFG_.LOG_SHEET, ['ts', 'version', 'level', 'evt', 'details']);
        sh.appendRow(row);
    }
    catch (e) {
        try {
            console.error('log_ fail: ' + e.message);
        }
        catch (_) { }
    }
}
function ensureSheet_(ss, name, header) {
    let sh = ss.getSheetByName(name);
    if (!sh) {
        sh = ss.insertSheet(name);
        if (header && header.length) {
            sh.getRange(1, 1, 1, header.length).setValues([header]);
        }
    }
    return sh;
}
function readTable_(sheetName) {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, sheetName);
        const rng = sh.getDataRange();
        const vals = rng.getValues();
        if (vals.length < 2)
            return { ok: true, header: vals[0] || [], rows: [] };
        const header = vals[0];
        const rows = vals.slice(1).map(r => Object.fromEntries(header.map((h, i) => [h, r[i]])));
        return { ok: true, header, rows };
    }
    catch (e) {
        return { ok: false, error: e.message };
    }
}
/**
 * Safely parses a JSON object from a raw string, which may be wrapped in markdown.
 * @param rawText The raw string response from the AI.
 * @returns A result object with the parsed data or an error.
 */
function parseAiJson_(rawText) {
    try {
        // 1. Clean the string: remove markdown fences, newlines, and trim whitespace.
        const cleanedText = rawText
            .replace(/```json/g, '')
            .replace(/```/g, '')
            .trim();
        const data = JSON.parse(cleanedText);
        return { ok: true, data: data };
    }
    catch (e) {
        log_('ERROR', 'parseAiJson_', { rawText: rawText, err: e.message });
        return { ok: false, error: `Failed to parse AI response as JSON: ${e.message}` };
    }
}
function appendRow_(sheetName, header, obj) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sh = ensureSheet_(ss, sheetName, header);
    const row = header.map(h => obj[h] ?? '');
    sh.appendRow(row);
    return { ok: true };
}
// ========== Block#2.1 — UTIL: Sheet Reader for Context Specialist (NEW) ==========
/**
 * Reads a sheet's data and returns it as a structured object array (rows mapped to headers).
 * This is the utility for the Project Context Specialist.
 * @param sheetName The name of the sheet to read.
 * @returns {object} {name: string, data: Record<string, any>[]} or {name: string, error: string}
 */
function util_readSheetAsJson_(sheetName) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
        return { name: sheetName, error: `Sheet not found.` };
    }
    try {
        // Reuse the existing robust readTable_ logic
        const result = readTable_(sheetName);
        if (!result.ok) {
            return { name: sheetName, error: result.error };
        }
        return { name: sheetName, data: result.rows };
    }
    catch (e) {
        return { name: sheetName, error: e.message };
    }
}
// ========== End Block#2.1 — UTIL: Sheet Reader for Context Specialist ==========
// ========== Block#3 — UTIL: AI & Settings ==========
function getSettings_() {
    try {
        const cache = CacheService.getScriptCache();
        const CACHE_KEY = 'polaris_settings';
        const cached = cache.get(CACHE_KEY);
        if (cached)
            return { ok: true, settings: JSON.parse(cached) };
        const tblResult = readTable_(CFG_.SETTINGS_SHEET);
        if (!tblResult.ok)
            return tblResult;
        if (!tblResult.rows.length) {
            return { ok: false, error: 'Settings sheet is empty or unreadable.' };
        }
        const settings = tblResult.rows.reduce((acc, row) => {
            const k = row.key || row.Key;
            const v = row.value || row.Value;
            if (k)
                acc[k] = v;
            return acc;
        }, {});
        if (!settings.OPENAI_API_KEY || !settings.OPENAI_MODEL) {
            log_('WARN', 'getSettings_', 'OPENAI_API_KEY or OPENAI_MODEL missing from Settings');
        }
        cache.put(CACHE_KEY, JSON.stringify(settings), 600); // Cache for 10 mins
        return { ok: true, settings };
    }
    catch (e) {
        log_('ERROR', 'getSettings_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
function callOpenAI_(systemPrompt, userText) {
    try {
        const settingsData = getSettings_();
        if (!settingsData.ok) {
            return { ok: false, error: `Failed to get settings: ${settingsData.error}` };
        }
        const { OPENAI_API_KEY, OPENAI_MODEL } = settingsData.settings;
        if (!OPENAI_API_KEY || !OPENAI_MODEL) {
            return { ok: false, error: 'OPENAI_API_KEY or OPENAI_MODEL is not set in the Settings sheet.' };
        }
        const url = 'https://api.openai.com/v1/chat/completions';
        const payload = {
            model: OPENAI_MODEL,
            messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userText }],
            max_tokens: 1024,
            temperature: 0.7,
        };
        const options = {
            method: 'post',
            contentType: 'application/json',
            headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` },
            payload: JSON.stringify(payload),
            // @ts-ignore - 'deadline' is a valid option but not in the current type definitions.
            deadline: 30, // Set a 30-second timeout for the API call
            muteHttpExceptions: true,
        };
        const httpResponse = UrlFetchApp.fetch(url, options);
        const httpCode = httpResponse.getResponseCode();
        const httpContent = httpResponse.getContentText();
        if (httpCode !== 200) {
            let errorMsg = `OpenAI API Error (${httpCode})`;
            try {
                const errorPayload = JSON.parse(httpContent);
                errorMsg = errorPayload?.error?.message || httpContent;
            }
            catch (e) { /* Ignore if response is not JSON */ }
            log_('ERROR', 'callOpenAI_http_error', { httpCode, errorMsg });
            return { ok: false, error: errorMsg };
        }
        try {
            const json = JSON.parse(httpContent);
            const responseText = json.choices[0]?.message?.content?.trim();
            if (responseText) {
                return { ok: true, response: responseText };
            }
            log_('WARN', 'callOpenAI_response_malformed', { httpContent });
            return { ok: false, error: 'OpenAI response was valid JSON but missing expected content.' };
        }
        catch (jsonError) {
            // This is critical for debugging if OpenAI returns non-JSON text
            log_('ERROR', 'callOpenAI_json_parse_error', { error: jsonError.message, rawResponse: httpContent });
            return { ok: false, error: 'Failed to parse OpenAI response as JSON.' };
        }
    }
    catch (e) {
        log_('ERROR', 'callOpenAI_fetch_error', { error: e.message, stack: e.stack });
        return { ok: false, error: `API ERROR: Failed to get response from OpenAI. Details: ${e.message}` };
    }
}
/* --- BLOCK END --- */

// FILE: 03_Persistence.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#2.5 — UTIL: Pending Actions Storage ==========
/**
 * Stores a pending action in the sheet.
 * Returns {ok: true, message: '...'} or {ok: false, error: '...'}
 */
function pending_save_(actionId, handlerKey, userId, spaceName, payload) {
    try {
        const rowData = {
            ActionID: actionId,
            Timestamp: new Date(),
            Status: 'PENDING',
            HandlerKey: handlerKey,
            UserID: userId,
            SpaceName: spaceName,
            ActionPayload: JSON.stringify(payload)
        };
        // CFG_PENDING_ is defined in 01_Config_Global.ts
        appendRow_(CFG_PENDING_.SHEET, [...CFG_PENDING_.HEADERS], rowData);
        return { ok: true };
    }
    catch (e) {
        log_('ERROR', 'pending_save_', { err: e.message, actionId });
        return { ok: false, error: 'Failed to save action to sheet.' };
    }
}
/**
 * Retrieves and marks an action as COMPLETED/DELETED in the sheet.
 * Returns {ok: true, payload: {...}} or {ok: false, error: '...'}
 */
function pending_getAndExecute_(actionId) {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, CFG_PENDING_.SHEET, [...CFG_PENDING_.HEADERS]);
        const data = sh.getDataRange().getValues();
        const headerRow = data[0];
        const actionIdCol = headerRow.indexOf('ActionID');
        const statusCol = headerRow.indexOf('Status');
        const payloadCol = headerRow.indexOf('ActionPayload');
        if (actionIdCol === -1 || statusCol === -1 || payloadCol === -1) {
            throw new Error("PendingActions sheet missing required columns.");
        }
        for (let i = 1; i < data.length; i++) {
            if (data[i][actionIdCol] === actionId) {
                const status = data[i][statusCol];
                if (status !== 'PENDING') {
                    return { ok: false, error: `Action ${actionId} status is '${status}'. Cannot execute.` };
                }
                const payload = JSON.parse(data[i][payloadCol]);
                sh.getRange(i + 1, statusCol + 1).setValue('COMPLETED');
                return { ok: true, payload: payload };
            }
        }
        return { ok: false, error: 'Action ID not found or already completed.' };
    }
    catch (e) {
        log_('ERROR', 'pending_getAndExecute_', { err: e.message, actionId });
        return { ok: false, error: `Sheet read/write error: ${e.message}` };
    }
}
/* --- BLOCK END --- */

// FILE: 04_Routing_NLP.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#4 — NLP Router (Query 1 - AI Powered) ==========
/**
 * Caches the handler manifest (from Handlers sheet) for 10 mins.
 */
function getHandlerManifest_() {
    try {
        const cache = CacheService.getScriptCache();
        const CACHE_KEY = 'polaris_handlers';
        const cached = cache.get(CACHE_KEY);
        if (cached)
            return { ok: true, handlers: JSON.parse(cached) };
        const tblResult = readTable_(CFG_.HANDLERS_SHEET);
        if (!tblResult.ok || !tblResult.rows.length) {
            return { ok: false, error: 'Handlers sheet is empty or unreadable.' };
        }
        const handlers = tblResult.rows.map(r => ({
            key: r.HandlerKey || r.name,
            fn: r.GAS_Function || r.fnName,
            desc: r.Description || r.description,
            fallback: r.FallbackHelpText || r.fallback
        })).filter(h => h.key && h.fn);
        if (!handlers.length) {
            return { ok: false, error: 'No valid handlers found in Handlers sheet.' };
        }
        cache.put(CACHE_KEY, JSON.stringify(handlers), 600); // Cache for 10 mins
        return { ok: true, handlers: handlers };
    }
    catch (e) {
        log_('ERROR', 'getHandlerManifest_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
/**
 * AI-Powered Router (Query 1).
 * Uses OpenAI to pick the best specialist from the Handlers sheet.
 */
function nlpPickCommand_(text) {
    try {
        const manifest = getHandlerManifest_();
        if (!manifest.ok) {
            return { ok: false, reason: 'handlers-not-found', err: manifest.error };
        }
        // Define core, built-in handlers to ensure they are always present and correctly described.
        const coreHandlers = [
            { key: 'handle_gmail', desc: 'Use to search, read, draft, or send emails.' },
            { key: 'handle_calendar', desc: 'Use to create, read, or manage calendar events.' },
            { key: 'handle_sheet_data', desc: 'Use to add or list items in a spreadsheet list (e.g., "add milk to groceries").' },
            { key: 'general_chat', desc: 'Use for general conversation or questions not covered by other tools.' },
            { key: 'help', desc: 'Use to ask for help or a list of capabilities.' },
            { key: 'get_version', desc: 'Returns the current deployment version of the script.' }
        ];
        const coreHandlerKeys = new Set(coreHandlers.map(h => h.key));
        // Filter out any core handlers from the sheet to avoid duplication, allowing sheet-based overrides if needed,
        // but primarily relying on the sheet for custom/new handlers.
        const customHandlers = manifest.handlers.filter(h => !coreHandlerKeys.has(h.key));
        const allHandlersForPrompt = [...coreHandlers, ...customHandlers];
        const toolList = allHandlersForPrompt.map(h => `HandlerKey: ${h.key}\nDescription: ${h.desc}`).join('\n---\n');
        const systemPrompt = `You are a "Query 1" router. Your ONLY job is to analyze the user's text and choose the single best HandlerKey from the provided list.
You must respond with ONLY the chosen HandlerKey and nothing else.
For example, if the user says "help me", you will respond with "help".
If no other tool is a good match for the user's request, you MUST respond with "general_chat".
Here is the list of available handlers:\n${toolList}`;
        const aiResult = callOpenAI_(systemPrompt, text);
        if (!aiResult.ok) {
            log_('ERROR', 'nlpPickCommand_AI_call', { err: aiResult.error });
            return { ok: false, reason: 'router-ai-error', err: aiResult.error };
        }
        const chosenHandlerKey = aiResult.response.trim().replace(/[."']/g, '');
        // Combine core and custom handlers for the final lookup. This is the fix.
        const allAvailableHandlers = [
            ...coreHandlers.map(h => ({ ...h, fn: `cmd_${h.key.charAt(0).toUpperCase() + h.key.slice(1).replace(/_([a-z])/g, g => g[1].toUpperCase())}_` })),
            ...manifest.handlers.filter(h => !coreHandlerKeys.has(h.key))
        ];
        let chosenHandler = allAvailableHandlers.find(h => h.key === chosenHandlerKey);
        if (!chosenHandler) {
            log_('WARN', 'nlpPickCommand_AI_mismatch', { text: text, chosenKey: chosenHandlerKey });
            chosenHandler = allAvailableHandlers.find(h => h.key === 'general_chat');
            if (!chosenHandler)
                return { ok: false, reason: 'no-match' }; // Failsafe
        }
        return { ok: true, handler: chosenHandler.fn, debug: { chosenKey: chosenHandler.key } };
    }
    catch (e) {
        log_('ERROR', 'nlpPickCommand_', { err: e.message });
        return { ok: false, reason: 'router-exception', err: e.message };
    }
}
/* --- BLOCK END --- */

// FILE: 05_Entrypoints.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#8.5 — Web App Entrypoint (doGet) ==========
/**
 * Handles GET requests from the approval hyperlink.
 */
function doGet(e) {
    try {
        const action = e.parameter.action;
        const pendingActionId = e.parameter.id;
        if (!pendingActionId) {
            return HtmlService.createHtmlOutput('<h1>❌ Invalid Link</h1><p>The link is missing a required action ID.</p>');
        }
        // The `action` parameter can be used to route to different handlers if needed in the future.
        // For now, all actions are handled by the pending action system.
        // This is the primary handler for sheet-based pending actions.
        const execResult = pending_getAndExecute_(pendingActionId);
        if (!execResult.ok) {
            return HtmlService.createHtmlOutput(`<h1>❌ Action Failed</h1><p>${execResult.error}</p>`);
        }
        // Assuming the payload is for gmail_send_ for now. This can be expanded later.
        const cmd = execResult.payload;
        // Add a runtime check to ensure the payload is valid before sending.
        if (!cmd || !cmd.to || !cmd.subject || !cmd.body) {
            return HtmlService.createHtmlOutput(`<h1>❌ Action Failed</h1><p>The action payload was incomplete or corrupted.</p>`);
        }
        const sendResult = gmail_send_(cmd);
        if (sendResult.ok) {
            return HtmlService.createHtmlOutput(`<h1>✅ Success!</h1><p>Email sent to **${cmd.to}** with subject: "${cmd.subject}".</p><p>You can now close this window.</p>`);
        }
        else {
            // The 'error' property is guaranteed by the return type of gmail_send_ on failure.
            return HtmlService.createHtmlOutput(`<h1>❌ Execution Failed</h1><p>Error sending email: ${sendResult.error}</p><p>Please inform the Polaris owner.</p>`);
        }
    }
    catch (error) {
        log_('ERROR', 'doGet_exception', { err: error.message, params: e.parameter });
        return HtmlService.createHtmlOutput('<h1>🚨 Critical Server Error</h1><p>An unexpected error occurred during execution.</p>');
    }
}
// ========== Block#9 — Add-on Event Entrypoints ==========
function resolveHandlerFn_(name) {
    const n = String(name || '');
    const globalScope = globalThis;
    if (typeof globalScope[n] === 'function')
        return globalScope[n];
    if (n.endsWith('_') && typeof globalScope[n.slice(0, -1)] === 'function')
        return globalScope[n.slice(0, -1)];
    if (!n.endsWith('_') && typeof globalScope[n + '_'] === 'function')
        return globalScope[n + '_'];
    return null;
}
function onMessage(event) {
    try {
        const text = (event.message?.text || '').trim();
        const route = nlpPickCommand_(text);
        log_('INFO', 'nlpPickCommand_decision', {
            text: text,
            decision: route.ok ? route.debug : route
        });
        if (!route.ok) {
            const userErr = route.reason === 'no-match' ? `🤖 Echo: ${text}` : `Router error: ${route.reason}`;
            return hostReply_({ text: userErr });
        }
        const fn = resolveHandlerFn_(route.handler);
        if (!fn)
            return hostReply_({ text: `Handler not found: ${route.handler}` });
        const out = fn({ text }); // Specialist runs
        if (out.ok && out.card) {
            return hostReply_({ cardsV2: [out.card] });
        }
        const reply = (out && out.message) || JSON.stringify(out);
        return hostReply_({ text: reply });
    }
    catch (e) {
        log_('ERROR', 'onMessage', { err: e.message });
        return hostReply_({ text: '⚠️ Error handling your message.' });
    }
}
/**
 * Host reply builder. Handles text OR cardsV2.
 */
function hostReply_(reply) {
    return {
        actionResponse: {
            type: 'NEW_MESSAGE',
            message: reply
        }
    };
}
/**
 * Entrypoint for all card clicks.
 */
function onCardClick(event) {
    try {
        // Assuming handleCardClick_ exists and is typed elsewhere
        return globalThis.handleCardClick_(event);
    }
    catch (e) {
        log_('ERROR', 'onCardClick_entry', { err: e.message, event: event });
        return {
            actionResponse: {
                type: 'REQUEST_CONFIG',
                dialogAction: {
                    dialog: {
                        body: {
                            text: `Error handling click: ${e.message}`
                        }
                    }
                }
            }
        };
    }
}
function onAddedToSpace(event) {
    try {
        return hostReply_({ text: '👋 Polaris PoC ready. Try: "add milk to HomeErrands" or "list HomeErrands"' });
    }
    catch (e) {
        return hostReply_({ text: '👋 Ready.' });
    }
}
function onRemovedFromSpace(event) {
    log_('INFO', 'onRemovedFromSpace', {});
}
/**
 * STUB for handling card clicks.
 * This function will be implemented to handle interactive card elements.
 */
function handleCardClick_(event) {
    log_('INFO', 'handleCardClick_', { event });
    // Placeholder response
    return { actionResponse: { type: 'UPDATE_MESSAGE', message: { text: 'Card click received!' } } };
}
/* --- BLOCK END --- */

// FILE: 06_Specialist_Sheet.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#5 — Specialist: Sheets (Query 2) ==========
function cmd_HandleSheetData_(params) {
    try {
        const text = params.text || '';
        const addMatch = text.match(/add\s+(.*)\s+to\s+([\w-]+)/i);
        const listMatch = text.match(/list\s+([\w-]+)/i);
        const agentsTblResult = readTable_(CFG_.DATAAGENTS_SHEET);
        const agentsTbl = (agentsTblResult.ok && agentsTblResult.rows) ? agentsTblResult.rows : [];
        const getAgentRowByName = (name) => {
            const n = String(name || '').toLowerCase();
            return agentsTbl.find(r => String(r.agentName || r.AgentName || '').toLowerCase() === n);
        };
        if (addMatch) {
            const item = addMatch[1].trim();
            const agentName = addMatch[2].trim();
            const row = getAgentRowByName(agentName);
            const sheetName = row ? (row.sheetName || row.SheetName || agentName) : agentName;
            const header = ['ts', 'item'];
            appendRow_(sheetName, header, { ts: new Date(), item });
            return { ok: true, message: `✅ Added to ${sheetName}: ${item}` };
        }
        if (listMatch) {
            const agentName = listMatch[1].trim();
            const row = getAgentRowByName(agentName);
            const sheetName = row ? (row.sheetName || row.SheetName || agentName) : agentName;
            const tbl = readTable_(sheetName);
            const items = (tbl.ok && tbl.rows) ? tbl.rows.map(r => `• ${r.item || JSON.stringify(r)}`).slice(0, 20) : [];
            return { ok: true, message: items.length ? `📋 ${sheetName}\n` + items.join('\n') : `📭 No items in ${sheetName}.` };
        }
        return { ok: false, message: `I can add/list items.\nTry: 'add milk to HomeErrands' or 'list HomeErrands'` };
    }
    catch (e) {
        log_('ERROR', 'cmd_HandleSheetData_', { err: e.message });
        return { ok: false, message: '⚠️ Sheet handler error.' };
    }
}
/* --- BLOCK END --- */

// FILE: 07_Specialist_Chat.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#6 — Specialists: Help, Chat, Search ==========
/**
 * Handles 'help' requests. Dynamically lists available handlers.
 */
function cmd_Help_(params) {
    try {
        const tblResult = readTable_(CFG_.HANDLERS_SHEET);
        if (!tblResult.ok || !tblResult.rows.length) {
            return { ok: false, message: '⚠️ Cannot read handlers from sheet.' };
        }
        const commands = tblResult.rows.map(r => {
            const key = r.HandlerKey || r.name;
            const desc = r.Description || r.description || 'No description.';
            return `• **${key}**: ${desc}`;
        }).join('\n');
        return { ok: true, message: `Here's what I can do:\n${commands}` };
    }
    catch (e) {
        log_('ERROR', 'cmd_Help_', { err: e.message });
        return { ok: false, message: '⚠️ Error getting help.' };
    }
}
/**
 * Handles 'general_chat' requests using Query 2 (OpenAI).
 * Fetches context from the 'Default' agent in DataAgents.
 */
function cmd_GeneralChat_(params) {
    try {
        const text = params.text || '';
        const agentsTblResult = readTable_(CFG_.DATAAGENTS_SHEET);
        // Temporary change to confirm deployment.
        let instructions = 'You are a helpful assistant. When you cannot answer a question, start your response with "My apologies, but..."';
        if (agentsTblResult.ok && agentsTblResult.rows.length) {
            const defaultAgent = agentsTblResult.rows.find(r => String(r.agentName || r.AgentName || '').toLowerCase() === CFG_.DEFAULT_AGENT.toLowerCase());
            if (defaultAgent) {
                const agentInstructions = defaultAgent.Instructions || defaultAgent.instructions;
                if (agentInstructions)
                    instructions = agentInstructions;
            }
        }
        const aiResult = callOpenAI_(instructions, text);
        if (!aiResult.ok) {
            return { ok: false, message: `⚠️ AI Error: ${aiResult.error}` };
        }
        return { ok: true, message: aiResult.response };
    }
    catch (e) {
        log_('ERROR', 'cmd_GeneralChat_', { err: e.message });
        return { ok: false, message: '⚠️ General chat error.' };
    }
}
/**
 * STUB for 'handle_web_search'.
 */
function cmd_HandleWebSearch_(params) {
    return {
        ok: false,
        message: '🤖 Web search is not implemented yet. We need to add a Search API (like Google Custom Search) first.'
    };
}
/**
 * Returns the current script version from the global config.
 * This is a simple utility to confirm which code version is deployed and running.
 */
function cmd_GetVersion_(params) {
    try {
        const version = CFG_.VERSION || 'unknown';
        return { ok: true, message: `✅ Polaris is running version: **${version}**` };
    }
    catch (e) {
        return { ok: false, message: '⚠️ Could not retrieve version information.' };
    }
}
/* --- BLOCK END --- */

// FILE: 08_Specialist_Cal.js
/* --- BLOCK START --- */
"use strict";
// ========== Block#7 — Specialists: Calendar (Query 2) ==========
/**
 * Helper function to get the fallback help text for this specialist.
 */
function getCalendarHelp_() {
    try {
        const manifest = getHandlerManifest_();
        if (!manifest.ok)
            return 'An error occurred.';
        const calHandler = manifest.handlers.find(h => h.key === 'handle_calendar');
        const fallbackMsg = (calHandler && calHandler.fallback)
            ? calHandler.fallback
            : 'Please be more specific. I may need a date, time, and title.'; // Hardcoded failsafe
        return `⚠️ ${fallbackMsg}`;
    }
    catch (e) {
        return '⚠️ To manage your calendar, please tell me what you want to do and when.';
    }
}
/**
 * Helper function to build a permalink for a Google Calendar event.
 */
function calendar_buildEventLink_(event) {
    try {
        const calId = event.getOriginalCalendarId();
        const eventId = event.getId().split('@')[0];
        const b64_eid = Utilities.base64Encode(`${eventId} ${calId}`);
        return `https://www.google.com/calendar/event?eid=${b64_eid}`;
    }
    catch (e) {
        log_('ERROR', 'calendar_buildEventLink_', { err: e.message });
        return '';
    }
}
/**
 * Helper function to read calendar events.
 */
function calendar_read_(cmd) {
    try {
        const { start, end, reply_lang: lang = 'en' } = cmd;
        const cal = CalendarApp.getDefaultCalendar();
        if (!cal)
            return { ok: false, message: "⚠️ Could not find default calendar." };
        const startTime = new Date(start);
        const endTime = new Date(end);
        const events = cal.getEvents(startTime, endTime);
        const tz = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
        if (!events.length) {
            const startStr = Utilities.formatDate(startTime, tz, "MMM d");
            const endStr = Utilities.formatDate(endTime, tz, "MMM d");
            const rangeStr = (startStr === endStr) ? startStr : `${startStr} to ${endStr}`;
            const message = lang === 'he' ? `🗓️ לא נמצאו אירועים עבור ${rangeStr}.` : `🗓️ No events found for ${rangeStr}.`;
            return { ok: true, message };
        }
        if (events.length === 1) {
            const event = events[0];
            const title = event.getTitle();
            let startStr = event.isAllDayEvent() ? (lang === 'he' ? '(כל היום)' : '(All Day)') : Utilities.formatDate(event.getStartTime(), tz, "h:mm a");
            const link = calendar_buildEventLink_(event);
            const linkText = lang === 'he' ? 'פתח ביומן' : 'Open in Calendar';
            const message = lang === 'he'
                ? `נמצא אירוע 1:\n• *${title}* [${startStr}] ${linkText}`
                : `Found 1 event:\n• *${title}* [${startStr}] ${linkText}`;
            return { ok: true, message };
        }
        const summaries = events.map(e => {
            const title = e.getTitle();
            let startStr = e.isAllDayEvent() ? (lang === 'he' ? '(כל היום)' : '(All Day)') : Utilities.formatDate(e.getStartTime(), tz, "h:mm a");
            const link = calendar_buildEventLink_(e);
            const linkText = lang === 'he' ? 'קישור' : 'link';
            return `• *${title}* [${startStr}] [[${linkText}]](${link})`;
        });
        const message = lang === 'he'
            ? `נמצאו ${summaries.length} אירועים:\n${summaries.join('\n')}`
            : `Found ${summaries.length} events:\n${summaries.join('\n')}`;
        return { ok: true, message };
    }
    catch (e) {
        log_('ERROR', 'calendar_read_', { err: e.message, cmd });
        return { ok: false, message: `⚠️ Error reading calendar events: ${e.message}` };
    }
}
/**
 * Helper function to create a calendar event.
 */
function calendar_create_(cmd) {
    try {
        const { title, start, end, reply_lang: lang = 'en' } = cmd;
        if (!title || !start || !end)
            return { ok: false, message: getCalendarHelp_() };
        const cal = CalendarApp.getDefaultCalendar();
        const startTime = new Date(start);
        const endTime = new Date(end);
        const tz = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
        const event = cal.createEvent(title, startTime, endTime);
        const startTimeStr = Utilities.formatDate(startTime, tz, "h:mm a");
        const startDateStr = Utilities.formatDate(startTime, tz, "MMM d, yyyy");
        const message = lang === 'he'
            ? `✅ אירוע נוצר בהצלחה: *${event.getTitle()}* ב-${startDateStr} בשעה ${startTimeStr}.`
            : `✅ Event created successfully: *${event.getTitle()}* on ${startDateStr} at ${startTimeStr}.`;
        return { ok: true, message };
    }
    catch (e) {
        log_('ERROR', 'calendar_create_', { err: e.message, cmd });
        return { ok: false, message: `⚠️ Error creating calendar event: ${e.message}` };
    }
}
/**
 * Handles 'handle_calendar' requests using Query 2 (OpenAI).
 */
function cmd_HandleCalendar_(params) {
    try {
        const text = params.text || '';
        const now = new Date();
        const tz = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
        const todayISO = Utilities.formatDate(now, tz, "yyyy-MM-dd'T'HH:mm:ss");
        const systemPrompt = `You are a "Query 2" Calendar specialist...`; // Prompt omitted for brevity
        const aiResult = callOpenAI_(systemPrompt, text);
        if (!aiResult.ok) {
            log_('ERROR', 'cmd_HandleCalendar_AI_call', { err: aiResult.error });
            return { ok: false, message: getCalendarHelp_() };
        }
        const parseResult = parseAiJson_(aiResult.response);
        if (!parseResult.ok) {
            log_('ERROR', 'cmd_HandleCalendar_json_parse', { response: aiResult.response, err: parseResult.error });
            return { ok: false, message: getCalendarHelp_() };
        }
        const cmd = parseResult.data;
        if (!cmd || !cmd.action)
            return { ok: false, message: getCalendarHelp_() };
        log_('INFO', 'cmd_HandleCalendar_cmd', { cmd });
        switch (cmd.action) {
            case 'read': return calendar_read_(cmd);
            case 'create': return calendar_create_(cmd);
            default:
                log_('WARN', 'cmd_HandleCalendar_unknown_action', { cmd });
                return { ok: false, message: getCalendarHelp_() };
        }
    }
    catch (e) {
        log_('ERROR', 'cmd_HandleCalendar_', { err: e.message });
        return { ok: false, message: '⚠️ Calendar handler error.' };
    }
}
/**
 * STUB for 'handle_tasks'.
 */
function cmd_HandleTasks_(params) {
    const text = params.text || '';
    return { ok: true, message: `🤖 **Tasks Stub:** I will soon handle: "${text}"` };
}
/* --- BLOCK END --- */

// FILE: 09_Specialist_Gmail.js
/* --- BLOCK START --- */
"use strict";
// FILE: ./09_Specialist_Gmail.ts
// ========== Block#8 — Specialist: Gmail (Query 2) ==========
/**
 * Helper function to get the fallback help text for this specialist.
 */
function getGmailHelp_() {
    try {
        const manifest = getHandlerManifest_();
        if (!manifest.ok)
            return 'An error occurred.';
        const gmailHandler = manifest.handlers.find(h => h.key === 'handle_gmail');
        return `⚠️ ${gmailHandler?.fallback || 'Please be more specific. I may need a recipient, subject, and body.'}`;
    }
    catch (e) {
        return '⚠️ To help with email, please be specific. For drafts, I need a recipient, subject, and body.';
    }
}
/**
 * Helper function to read Gmail threads based on a query.
 */
function gmail_read_(cmd) {
    try {
        const { query, count, reply_lang: lang = 'en' } = cmd;
        const num = Math.min(Math.max(count || 3, 1), 10);
        const threads = GmailApp.search(query, 0, num);
        if (!threads.length) {
            const message = lang === 'he' ? `📭 לא נמצאו אימיילים עבור השאילתה: "${query}"` : `📭 No emails found for query: "${query}"`;
            return { ok: true, message };
        }
        if (threads.length === 1) {
            const thread = threads[0];
            const subject = thread.getFirstMessageSubject();
            const from = thread.getMessages()[0].getFrom().split('<')[0].trim();
            const link = thread.getPermalink();
            const linkText = lang === 'he' ? 'פתח ב-Gmail' : 'Open in Gmail';
            const message = lang === 'he'
                ? `נמצא אימייל 1:\n• *${subject}* (מאת ${from}) ${linkText}`
                : `Found 1 email:\n• *${subject}* (from ${from}) ${linkText}`;
            return { ok: true, message };
        }
        const summaries = threads.map(t => {
            const subject = t.getFirstMessageSubject();
            const from = t.getMessages()[0].getFrom().split('<')[0].trim();
            const fromText = lang === 'he' ? 'מאת' : 'from';
            return `• *${subject}* (${fromText} ${from})`;
        });
        const message = lang === 'he'
            ? `נמצאו ${summaries.length} אימיילים:\n${summaries.join('\n')}`
            : `Found ${summaries.length} emails:\n${summaries.join('\n')}`;
        return { ok: true, message };
    }
    catch (e) {
        log_('ERROR', 'gmail_read_', { err: e.message, query: cmd.query });
        return { ok: false, message: `⚠️ Error reading emails: ${e.message}` };
    }
}
/**
 * Helper function to SEND a Gmail email.
 */
function gmail_send_(cmd) {
    try {
        const { to, subject, body, reply_lang: lang = 'en' } = cmd;
        if (!to || !subject || !body)
            return { ok: false, error: 'Missing to, subject, or body' };
        GmailApp.sendEmail(to, subject, body);
        const successMsg = lang === 'he' ? `✅ נשלח בהצלחה אל: ${to}` : `✅ Successfully sent to: ${to}`;
        return { ok: true, message: successMsg };
    }
    catch (e) {
        log_('ERROR', 'gmail_send_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
/**
 * Handles 'handle_gmail' requests using Query 2 (OpenAI).
 */
function cmd_HandleGmail_(params) {
    try {
        const text = params.text || '';
        const systemPrompt = `You are a "Query 2" Gmail specialist. Your ONLY job is to convert the user's request into a single, valid JSON command.

You must respond with ONLY the JSON object and nothing else.
You must choose one of the following actions: "read" or "draft".
You MUST also include a "reply_lang" key set to the detected language of the user's prompt (e.g., "en", "he").

1.  **"read" action**:
    * User: "show me my last 3 unread emails from 'hello@world.com'"
        -> {"action": "read", "query": "is:unread from:hello@world.com", "count": 3, "reply_lang": "en"}

2.  **"draft" action**:
    * User: "draft an email to reuven007@gmail.com with the subject 'Polaris Test Draft' and the body 'This is a test message.'"
        -> {"action": "draft", "to": "reuven007@gmail.com", "subject": "Polaris Test Draft", "body": "This is a test message.", "reply_lang": "en"}
    * User: "שלח מייל ל-test@example.com עם נושא 'בדיקה' ותוכן 'זוהי הודעת בדיקה'"
        -> {"action": "draft", "to": "test@example.com", "subject": "בדיקה", "body": "זוהי הודעת בדיקה", "reply_lang": "he"}

If any required field for a draft (to, subject, body) is missing from the user's text, you MUST return that field as null in the JSON.
For example, if the user says "draft an email to bob":
-> {"action": "draft", "to": "bob", "subject": null, "body": null, "reply_lang": "en"}`;
        const aiResult = callOpenAI_(systemPrompt, text);
        if (!aiResult.ok) {
            log_('ERROR', 'cmd_HandleGmail_AI_call', { err: aiResult.error });
            return { ok: false, message: getGmailHelp_() };
        }
        const parseResult = parseAiJson_(aiResult.response);
        if (!parseResult.ok) {
            log_('ERROR', 'cmd_HandleGmail_json_parse', { response: aiResult.response, err: parseResult.error });
            return { ok: false, message: getGmailHelp_() };
        }
        // Use 'let' and type as 'any' to allow for in-memory correction of the object from the AI.
        let cmd = parseResult.data;
        // ============= [CRITICAL FIX: AI Mismatch Correction] =============
        // 1. Correct the common AI error: recipient field named 'email' instead of 'to'.
        if (cmd.email && !cmd.to) {
            cmd.to = cmd.email;
            delete cmd.email;
        }
        // 2. Implied Action: If the primary fields (to, subject, body) are present, assume the action is 'draft'.
        if (!cmd.action && cmd.to && cmd.subject) {
            cmd.action = 'draft';
        }
        // =================================================================
        if (!cmd || !cmd.action)
            return { ok: false, message: getGmailHelp_() };
        log_('INFO', 'cmd_HandleGmail_cmd', { cmd });
        switch (cmd.action) {
            case 'read':
                return gmail_read_(cmd);
            case 'draft':
                const { to, subject, body, reply_lang: lang = 'en' } = cmd;
                // Final validation after correction
                if (!to || !subject || !body)
                    return { ok: false, message: getGmailHelp_() };
                // NOTE: The implementation for Policy Confirmation goes here
                // For now, we simulate the pending action save and approval URL response.
                const pendingActionId = `gmail-send-${Utilities.getUuid()}`;
                const saveResult = pending_save_(pendingActionId, 'handle_gmail', params.user, params.space, cmd);
                if (!saveResult.ok) {
                    log_('ERROR', 'cmd_HandleGmail_save_failed', { err: saveResult.error });
                    return { ok: false, message: '⚠️ Could not save pending action. Please try again.' };
                }
                // NOTE: The final approval link needs to be constructed and returned here.
                // Returning a generic message for now until Block #4.1 is fully integrated.
                return { ok: true, message: `✅ Draft proposal queued (ID: ${pendingActionId}). Awaiting approval link send.` };
            default:
                log_('WARN', 'cmd_HandleGmail_unknown_action', { cmd });
                return { ok: false, message: getGmailHelp_() };
        }
    }
    catch (e) {
        log_('ERROR', 'cmd_HandleGmail_', { err: e.message });
        return { ok: false, message: '⚠️ Gmail handler error.' };
    }
}
/* --- BLOCK END --- */

// FILE: 10_Dev_Tools.js
/* --- BLOCK START --- */
"use strict";
/*
 * Contains Manual functions for setup (authorization) and Sheet-bound UI
 * elements.
 * (Blocks #11 and #12)
 */
// ========== Block#11 — UTIL: Manual Authorization ==========
/**
 * Run this function MANUALLY from the Apps Script editor
 * to trigger the authorization prompt for all required scopes.
 */
// Test comment
function authorize_() {
    try {
        // 1. Sheets
        SpreadsheetApp.getActiveSpreadsheet().getName();
        // 2. Calendar
        CalendarApp.getDefaultCalendar().getName();
        // 3. Tasks (Requires enabling the Google Tasks API in your GCP project)
        if (typeof Tasks !== 'undefined' && Tasks.Tasklists) {
            const taskLists = Tasks.Tasklists.list();
            if (taskLists && taskLists.items) {
                const taskList = taskLists.items.find(l => l.title === 'Polaris');
                if (!taskList) {
                    Tasks.Tasklists.insert({ title: 'Polaris' });
                }
            }
        }
        // 4. Gmail (Read & Compose)
        GmailApp.getInboxUnreadCount(); // Read-only
        GmailApp.getDrafts(); // Compose (accessing drafts)
        GmailApp.sendEmail(Session.getActiveUser().getEmail(), 'Auth Test', 'Test'); // Send
        // 5. External Request (OpenAI)
        UrlFetchApp.fetch('https://api.openai.com', { muteHttpExceptions: true });
        // 6. Cache
        CacheService.getScriptCache().put('auth_test', 'ok', 60);
        Logger.log('✅ All services accessed. Permissions are (or will be) granted.');
    }
    catch (e) {
        Logger.log(`⚠️ Authorization Error: ${e.message}. This is normal if you haven't granted permissions yet. Please follow the pop-up flow.`);
    }
}
/**
 * MANUAL RUNNER (The "Thin Wrapper" fix)
 */
function RUN_THIS_TO_AUTHORIZE_() {
    authorize_();
}
// ========== Block#12 — UI & SHEET TRIGGERS ==========
/**
 * Helper function to generate a HTML table from the 'Codebase' sheet data.
 */
function buildCodebaseHtml_() {
    try {
        const sh = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Codebase');
        if (!sh)
            return '<p>Codebase sheet not found.</p>';
        const data = sh.getDataRange().getValues();
        if (data.length === 0)
            return '<p>Codebase is empty.</p>';
        let html = '<style>table {border-collapse: collapse; width: 100%; font-size: 10px;} th, td {border: 1px solid #ddd; padding: 4px; text-align: left;} th {background-color: #f2f2f2;}</style><table><thead><tr>';
        data[0].forEach(header => { html += `<th>${header}</th>`; });
        html += '</tr></thead><tbody>';
        for (let i = 1; i < data.length; i++) {
            html += '<tr>';
            data[i].forEach(cell => { html += `<td>${String(cell)}</td>`; });
            html += '</tr>';
        }
        html += '</tbody></table>';
        return html;
    }
    catch (e) {
        console.error('Error loading codebase table:', e.message);
        return 'Error loading codebase table.';
    }
}
function showCodebaseTable() {
    const htmlOutput = HtmlService.createHtmlOutput(buildCodebaseHtml_()).setTitle('Polaris Project Codebase');
    SpreadsheetApp.getUi().showSidebar(htmlOutput);
}
/* --- BLOCK END --- */

// FILE: 11_Governance.js
/* --- BLOCK START --- */
"use strict";
/* --- BLOCK END --- */

// FILE: index.js
/* --- BLOCK START --- */
"use strict";
/**
 * Creates a custom menu in the Google Sheet UI when the sheet is opened..
 */
function onOpen() {
    try {
        SpreadsheetApp.getUi()
            .createMenu('🤖 Polaris Agent (TS)')
            .addItem('Say Hello', 'sayHello')
            .addToUi();
    }
    catch (e) {
        console.error('onOpen failed: Likely non-UI context or permission issue.', e.message);
    }
}
function sayHello() {
    SpreadsheetApp.getUi().alert('Hello from TypeScript!');
}
/* --- BLOCK END --- */

/* --- END OF POLARIS CODEBASE --- */
