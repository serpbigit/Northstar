/* --- START OF POLARIS CODEBASE --- */
// DO NOT EDIT THIS FILE DIRECTLY. EDIT THE SOURCE .TS FILES.

// FILE: northstarUnified.ts
/* --- BLOCK START --- */
// ---------------------------------------------------------------------------------
// FILE: 01_ConfigAndUtils.ts
// PURPOSE: Global configuration constants, logging, core Sheet utilities, and function resolver.
// ---------------------------------------------------------------------------------
// ========== Block#1 ‚Äî CONFIG ==========
/**
 * Global configuration constants for sheet names.
 */
const CFG_ = {
    SETTINGS_SHEET: 'Settings',
    HANDLERS_SHEET: 'Handlers',
    DATAAGENTS_SHEET: 'DataAgents',
    SHARED_POLICIES_SHEET: 'SharedPolicies',
    LOG_SHEET: 'Log',
    JOBS_QUEUE_SHEET: 'PendingActions',
    DEFAULT_AGENT: 'Default',
};
// ========== Block#2 ‚Äî UTIL: Logging & Sheets ==========
/**
 * Ensures a sheet exists and creates it with a header if missing.
 */
function ensureSheet_(ss, name, header = []) {
    let sh = ss.getSheetByName(name);
    if (!sh) {
        sh = ss.insertSheet(name);
        if (header && header.length)
            sh.getRange(1, 1, 1, header.length).setValues([header]);
    }
    return sh;
}
/**
 * Centralized, structured execution and debugging log (Archivist Agent reliance).
 */
function log_(level, evt, data) {
    try {
        const row = [
            new Date(),
            level,
            evt,
            JSON.stringify(data || {}).slice(0, 3000)
        ];
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, CFG_.LOG_SHEET, ['ts', 'level', 'evt', 'details']);
        sh.appendRow(row);
    }
    catch (e) {
        try {
            console.error('log_ fail: ' + e.message);
        }
        catch (_) { }
    }
}
/**
 * Reads a sheet table, converting rows into an array of objects based on the header.
 */
function readTable_(sheetName) {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, sheetName);
        const rng = sh.getDataRange();
        const vals = rng.getValues();
        if (vals.length < 1)
            return { ok: true, header: [], rows: [] };
        const header = vals[0].map((h) => String(h).trim());
        if (vals.length < 2)
            return { ok: true, header, rows: [] };
        const rows = vals.slice(1).map((r) => Object.fromEntries(header.map((h, i) => [h, r[i]])));
        return { ok: true, header, rows };
    }
    catch (e) {
        log_('ERROR', 'readTable_', { err: e.message, sheet: sheetName });
        return { ok: false, error: e.message, header: [], rows: [] };
    }
}
/**
 * Appends an object's values to a sheet row based on a required header array.
 */
function appendRow_(sheetName, header, obj) {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sh = ensureSheet_(ss, sheetName, header);
        const row = header.map((h) => obj[h] ?? '');
        sh.appendRow(row);
        return { ok: true };
    }
    catch (e) {
        log_('ERROR', 'appendRow_', { err: e.message, sheet: sheetName, data: obj });
        return { ok: false, error: e.message };
    }
}
/**
 * Helper function used by the LibraryInterface to resolve GAS functions dynamically.
 * *** FIX: Explicitly type 'this' to resolve TS2683 error ***
 */
function resolveHandlerFn_(name) {
    const n = String(name || '');
    // Check global scope using the explicitly typed 'this'
    if (typeof this[n] === 'function')
        return this[n];
    if (n.endsWith('_') && typeof this[n.slice(0, -1)] === 'function')
        return this[n.slice(0, -1)];
    if (!n.endsWith('_') && typeof this[n + '_'] === 'function')
        return this[n + '_'];
    return null;
}
/**
 * Manually callable function to set up the minimal Polaris sheet structure.
 */
function GoogleSheets_Setup() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ui = SpreadsheetApp.getUi();
    try {
        // 1. Create essential system sheets with their headers
        ensureSheet_(ss, CFG_.SETTINGS_SHEET, ['Key', 'Value']);
        ensureSheet_(ss, CFG_.LOG_SHEET, ['ts', 'level', 'evt', 'details']);
        ensureSheet_(ss, CFG_.HANDLERS_SHEET, ['HandlerKey', 'GAS_Function', 'Description']);
        ensureSheet_(ss, CFG_.DATAAGENTS_SHEET, ['agentName', 'Instructions', 'TargetSheet']);
        ensureSheet_(ss, CFG_.JOBS_QUEUE_SHEET, [
            'ActionPlan_ID', 'User_ID', 'Created_TS', 'Status', 'Name',
            'Total_Steps', 'Current_Step_Idx', 'Execution_Log', 'Action_Plan_JSON'
        ]);
        ui.alert('‚úÖ Polaris Setup Complete!', 'All essential system sheets have been created and initialized.', ui.ButtonSet.OK);
    }
    catch (e) {
        console.error('Setup Error: ' + e.message);
        ui.alert('‚ö†Ô∏è Setup Failed', 'An error occurred during sheet creation: ' + e.message, ui.ButtonSet.OK);
    }
}
// ---------------------------------------------------------------------------------
// FILE: 02_OpenAIClient.ts
// PURPOSE: Handles settings retrieval and the secure external call to the OpenAI API.
// ---------------------------------------------------------------------------------
// NOTE: This file depends on CFG_, log_(), and readTable_() from 01_ConfigAndUtils.ts
/**
 * Gets key-value pairs from the Settings sheet.
 * Caches settings for 10 minutes to reduce Sheet API calls.
 * @returns {object} {ok: true, settings: object} or {ok: false, error: string}
 */
function getSettings_() {
    try {
        const cache = CacheService.getScriptCache();
        const CACHE_KEY = 'polaris_settings';
        const cached = cache.get(CACHE_KEY);
        if (cached)
            return { ok: true, settings: JSON.parse(cached) };
        const tbl = readTable_(CFG_.SETTINGS_SHEET);
        if (!tbl.ok || !tbl.rows.length) {
            return { ok: false, error: 'Settings sheet is empty or unreadable.' };
        }
        // Assumes Settings sheet has 'Key' and 'Value' columns
        const settings = tbl.rows.reduce((acc, row) => {
            const k = row.Key || row.key;
            const v = row.Value || row.value;
            if (k)
                acc[k] = v;
            return acc;
        }, {});
        if (!settings.OPENAI_API_KEY || !settings.OPENAI_MODEL) {
            log_('WARN', 'getSettings_', 'OPENAI_API_KEY or OPENAI_MODEL missing from Settings');
        }
        cache.put(CACHE_KEY, JSON.stringify(settings), 600);
        return { ok: true, settings };
    }
    catch (e) {
        log_('ERROR', 'getSettings_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
/**
 * Calls the OpenAI Chat Completions API using UrlFetchApp.
 * @param {string} systemPrompt The system-level instruction for the AI.
 * @param {string} userText The user's input text.
 * @returns {object} {ok: true, response: string} or {ok: false, error: string}
 */
function callOpenAI_(systemPrompt, userText) {
    try {
        // 1. Get API Key and Model from settings
        const settingsData = getSettings_();
        if (!settingsData.ok) {
            return { ok: false, error: `Failed to get settings: ${settingsData.error}` };
        }
        const { OPENAI_API_KEY, OPENAI_MODEL } = settingsData.settings;
        if (!OPENAI_API_KEY || !OPENAI_MODEL) {
            return { ok: false, error: 'OPENAI_API_KEY or OPENAI_MODEL is not set in the Settings sheet.' };
        }
        // 2. Prepare the HTTP request payload and options
        const url = 'https://api.openai.com/v1/chat/completions';
        const payload = {
            model: OPENAI_MODEL,
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userText }
            ],
            max_tokens: 1024,
            temperature: 0.7,
        };
        const options = {
            method: 'post',
            contentType: 'application/json',
            headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` },
            payload: JSON.stringify(payload),
            muteHttpExceptions: true,
        };
        // 3. Execute the external request
        const httpResponse = UrlFetchApp.fetch(url, options);
        const httpCode = httpResponse.getResponseCode();
        const httpContent = httpResponse.getContentText();
        // 4. Handle non-200 HTTP errors
        if (httpCode !== 200) {
            log_('ERROR', 'callOpenAI_', { httpCode, httpContent: httpContent.slice(0, 500) });
            return { ok: false, error: `OpenAI API Error ${httpCode}: ${httpContent.slice(0, 500)}` };
        }
        // 5. Parse and return the successful response
        const json = JSON.parse(httpContent);
        const responseText = json.choices[0].message.content.trim();
        return { ok: true, response: responseText };
    }
    catch (e) {
        log_('ERROR', 'callOpenAI_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
// ---------------------------------------------------------------------------------
// FILE: 03_CoreAgents.ts
// PURPOSE: Contains the Router (Query 1) and Core Cognitive Agent specialists.
// NOTE: This file depends on files 01, 02, and 05 (MonetizationGate).
// ---------------------------------------------------------------------------------
// ========== Block#3 ‚Äî NLP Router (Query 1 - AI Powered) ==========
/**
 * Caches the handler manifest (from Handlers sheet) for 10 mins.
 */
function getHandlerManifest_() {
    try {
        const cache = CacheService.getScriptCache();
        const CACHE_KEY = 'polaris_handlers';
        const cached = cache.get(CACHE_KEY);
        if (cached)
            return { ok: true, handlers: JSON.parse(cached) };
        const tbl = readTable_(CFG_.HANDLERS_SHEET);
        if (!tbl.ok || !tbl.rows.length) {
            return { ok: false, error: 'Handlers sheet is empty or unreadable.' };
        }
        const handlers = tbl.rows.map((r) => ({
            key: r.HandlerKey || r.name,
            fn: r.GAS_Function || r.fnName,
            desc: r.Description || r.description,
        })).filter((h) => h.key && h.fn);
        if (!handlers.length) {
            return { ok: false, error: 'No valid handlers found in Handlers sheet.' };
        }
        cache.put(CACHE_KEY, JSON.stringify(handlers), 600);
        return { ok: true, handlers: handlers, handlerKeys: handlers.map((h) => h.key) };
    }
    catch (e) {
        log_('ERROR', 'getHandlerManifest_', { err: e.message });
        return { ok: false, error: e.message };
    }
}
/**
 * AI-Powered Router (Query 1).
 * @param {string} text The user's input query.
 * @returns {object} {ok: true, handler: string, handlerKey: string} or {ok: false, reason: string, err: string}
 */
function nlpPickCommand_(text) {
    try {
        if (text.trim().startsWith('IACP:')) {
            log_('INFO', 'nlpPickCommand_IACP', { status: 'STUB_BYPASS' });
        }
        const manifest = getHandlerManifest_();
        if (!manifest.ok) {
            return { ok: false, reason: 'handlers-not-found', err: manifest.error };
        }
        const toolList = manifest.handlers.map((h) => `HandlerKey: ${h.key}\nDescription: ${h.desc}`).join('\n---\n');
        const systemPrompt = `You are a "Query 1" router.
Your ONLY job is to analyze the user's text and choose the single best HandlerKey from the provided list.
You must respond with ONLY the chosen HandlerKey and nothing else.
If you cannot find a good match, you MUST respond with "general_chat".

Here is the list of available handlers:
${toolList}`;
        const aiResult = callOpenAI_(systemPrompt, text);
        if (!aiResult.ok) {
            log_('ERROR', 'nlpPickCommand_AI_call', { err: aiResult.error });
            return { ok: false, reason: 'router-ai-error', err: aiResult.error };
        }
        const chosenHandlerKey = aiResult.response.trim().replace(/[."']/g, '');
        const chosenHandler = manifest.handlers.find((h) => h.key === chosenHandlerKey);
        if (!chosenHandler) {
            log_('WARN', 'nlpPickCommand_AI_mismatch', {
                text: text,
                chosenKey: chosenHandlerKey
            });
            const generalChatHandler = manifest.handlers.find((h) => h.key === 'general_chat');
            if (generalChatHandler) {
                return { ok: true, handler: generalChatHandler.fn, handlerKey: 'general_chat', debug: { chosenKey: 'general_chat (fallback)' } };
            }
            return { ok: false, reason: 'no-match', err: `AI returned invalid key: ${chosenHandlerKey}` };
        }
        return { ok: true, handler: chosenHandler.fn, handlerKey: chosenHandler.key, debug: { chosenKey: chosenHandlerKey } };
    }
    catch (e) {
        log_('ERROR', 'nlpPickCommand_', { err: e.message });
        return { ok: false, reason: 'router-exception', err: e.message };
    }
}
// ========== Block#4 ‚Äî Core Specialists (Help, Chat, Search) ==========
/**
 * Handles 'help' requests. Dynamically lists available handlers.
 */
function cmd_Help_(params) {
    try {
        const tbl = readTable_(CFG_.HANDLERS_SHEET);
        if (!tbl.ok || !tbl.rows.length) {
            return { ok: false, message: '‚ö†Ô∏è Cannot read handlers from sheet.' };
        }
        const commands = tbl.rows.map((r) => {
            const key = r.HandlerKey || r.name;
            const desc = r.Description || r.description || 'No description.';
            return `‚Ä¢ **${key}**: ${desc}`;
        }).join('\n');
        return { ok: true, message: `Here's what I can do:\n${commands}` };
    }
    catch (e) {
        log_('ERROR', 'cmd_Help_', { err: e.message });
        return { ok: false, message: '‚ö†Ô∏è Error getting help.' };
    }
}
/**
 * Handles 'general_chat' requests using Query 2 (OpenAI).
 */
function cmd_GeneralChat_(params) {
    try {
        const text = params.text || '';
        const agentsTbl = readTable_(CFG_.DATAAGENTS_SHEET);
        let instructions = 'You are a helpful assistant.';
        if (agentsTbl.ok && agentsTbl.rows.length) {
            const defaultAgent = agentsTbl.rows.find((r) => String(r.agentName || r.AgentName || '').toLowerCase() === CFG_.DEFAULT_AGENT.toLowerCase());
            if (defaultAgent) {
                const agentInstructions = defaultAgent.Instructions || defaultAgent.instructions;
                if (agentInstructions)
                    instructions = agentInstructions;
            }
        }
        const aiResult = callOpenAI_(instructions, text);
        if (!aiResult.ok) {
            return { ok: false, message: `‚ö†Ô∏è AI Error: ${aiResult.error}` };
        }
        return { ok: true, message: aiResult.response };
    }
    catch (e) {
        log_('ERROR', 'cmd_GeneralChat_', { err: e.message });
        return { ok: false, message: '‚ö†Ô∏è General chat error.' };
    }
}
/**
 * STUB for 'handle_web_search'.
 */
function cmd_HandleWebSearch_(params) {
    return {
        ok: false,
        message: 'ü§ñ Web search is not implemented yet. We need to add a Search API first.'
    };
}
// ---------------------------------------------------------------------------------
// FILE: 04_SwarmSpecialists.ts
// PURPOSE: Contains all Domain Swarm Agents (execution logic for external APIs).
// NOTE: This file depends on files 01 and 02.
// ---------------------------------------------------------------------------------
// ========== Specialist: Sheets (CRUD operations) ==========
/**
 * Helper to find a data agent configuration row by name from the DataAgents sheet.
 * @param {string} agentName The name of the agent to look up.
 * @param {object[]} agentsTblRows The rows from the DataAgents sheet.
 * @returns {object | undefined} The agent configuration row.
 */
function getAgentRowByName_(agentName, agentsTblRows) {
    const n = String(agentName || '').toLowerCase();
    return agentsTblRows.find((r) => String(r.agentName || r.AgentName || '').toLowerCase() === n);
}
/**
 * Handles sheet data manipulation commands ("add X to List" or "list List").
 * @param {object} params Object containing {text: string} and {userId: string}.
 * @returns {object} {ok: boolean, message: string}
 */
function cmd_HandleSheetData_(params) {
    try {
        const text = params.text || '';
        const addMatch = text.match(/add\s+(.*)\s+to\s+([\w-]+)/i);
        const listMatch = text.match(/list\s+([\w-]+)/i);
        const agentsTbl = readTable_(CFG_.DATAAGENTS_SHEET).rows || [];
        if (addMatch) {
            const item = addMatch[1].trim();
            const agent = addMatch[2].trim();
            const row = getAgentRowByName_(agent, agentsTbl);
            const sheetName = row ? (row.sheetName || row.SheetName || agent) : agent;
            const header = ['ts', 'item'];
            appendRow_(sheetName, header, { ts: new Date(), item });
            return { ok: true, message: `‚úÖ Added to ${sheetName}: ${item}` };
        }
        if (listMatch) {
            const agent = listMatch[1].trim();
            const row = getAgentRowByName_(agent, agentsTbl);
            const sheetName = row ? (row.sheetName || row.SheetName || agent) : agent;
            const tbl = readTable_(sheetName);
            const items = (tbl.rows || []).map((r) => `‚Ä¢ ${r.item || JSON.stringify(r)}`).slice(0, 20);
            return { ok: true, message: items.length ?
                    `üìã ${sheetName}\n` + items.join('\n') : `üì≠ No items in ${sheetName}.`
            };
        }
        return {
            ok: false,
            message: `I can add/list items.\nTry: 'add milk to HomeErrands' or 'list HomeErrands'`
        };
    }
    catch (e) {
        log_('ERROR', 'cmd_HandleSheetData_', { err: e.message });
        return { ok: false, message: '‚ö†Ô∏è Sheet handler error.' };
    }
}
// ========== Specialist: Gmail (Read/Draft Helpers) ==========
/**
 * Helper function to read Gmail threads based on a query.
 */
function gmail_read_(query, count) {
    try {
        const num = Math.min(Math.max(parseInt(count) || 3, 1), 10);
        const threads = GmailApp.search(query, 0, num);
        if (!threads.length) {
            return { ok: true, message: `üì≠ No emails found for query: "${query}"` };
        }
        const summaries = threads.map((t) => {
            const firstMsg = t.getMessages()[0];
            const subject = t.getFirstMessageSubject();
            const from = firstMsg.getFrom().split('<')[0].trim();
            return `‚Ä¢ *${subject}* (from ${from})`;
        });
        return {
            ok: true,
            message: `Found ${summaries.length} emails:\n${summaries.join('\n')}`
        };
    }
    catch (e) {
        log_('ERROR', 'gmail_read_', { err: e.message, query });
        return { ok: false, message: `‚ö†Ô∏è Error reading emails: ${e.message}` };
    }
}
/**
 * Helper function to create a Gmail draft.
 */
function gmail_draft_(to, subject, body) {
    try {
        if (!to || !subject || !body) {
            return { ok: false, message: `‚ö†Ô∏è AI failed to provide to, subject, or body.` };
        }
        const draft = GmailApp.createDraft(to, subject, body);
        return {
            ok: true,
            message: `‚úÖ Draft created successfully.\n**To:** ${to}\n**Subject:** ${subject}\n\nI have saved this in your Drafts folder for you to review and send.`
        };
    }
    catch (e) {
        log_('ERROR', 'gmail_draft_', { err: e.message });
        return { ok: false, message: `‚ö†Ô∏è Error creating draft: ${e.message}` };
    }
}
/**
 * Handles 'handle_gmail' requests using Query 2 (OpenAI).
 */
function cmd_HandleGmail_(params) {
    try {
        const text = params.text || '';
        // 1. Define the System Prompt for the Gmail Specialist (Query 2)
        const systemPrompt = `You are a "Query 2" Gmail specialist.
Your ONLY job is to convert the user's request into a single, valid JSON command.
You must choose one of the following actions: "read" or "draft".

1.  **"read" action**: Use for any request to find, list, or read emails.
    Example: {"action": "read", "query": "from:bob@acme.com in:inbox", "count": 5}

2.  **"draft" action**: Use for any request to write, compose, or draft an email.
    Example: {"action": "draft", "to": "sales@acme.com", "subject": "New PO #12345", "body": "Hello,\n\nPlease find attached PO #12345.\n\nBest,"}

Respond with ONLY the JSON object and nothing else.`;
        // 2. Call OpenAI (Query 2)
        const aiResult = callOpenAI_(systemPrompt, text);
        if (!aiResult.ok) {
            return { ok: false, message: `‚ö†Ô∏è AI Error (Query 2): ${aiResult.error}` };
        }
        // 3. Parse the AI's JSON command
        let cmd;
        try {
            const jsonString = aiResult.response.replace(/```json\n|```/g, '').trim();
            cmd = JSON.parse(jsonString);
        }
        catch (e) {
            log_('ERROR', 'cmd_HandleGmail_json_parse', { response: aiResult.response, err: e.message });
            return { ok: false, message: `‚ö†Ô∏è AI returned invalid JSON: ${aiResult.response}` };
        }
        // 4. Execute the command
        log_('INFO', 'cmd_HandleGmail_cmd', { cmd });
        switch (cmd.action) {
            case 'read':
                return gmail_read_(cmd.query, cmd.count);
            case 'draft':
                return gmail_draft_(cmd.to, cmd.subject, cmd.body);
            default:
                return { ok: false, message: `‚ö†Ô∏è AI returned an unknown action: ${cmd.action}` };
        }
    }
    catch (e) {
        log_('ERROR', 'cmd_HandleGmail_', { err: e.message });
        return { ok: false, message: '‚ö†Ô∏è Gmail handler error.' };
    }
}
// ========== Specialist: Calendar (Stub) ==========
function cmd_HandleCalendar_(params) {
    return { ok: true, message: `üìÖ CALENDAR STUB: I will soon handle: "${params.text || ''}".` };
}
// ========== Specialist: Tasks (Stub) ==========
function cmd_HandleTasks_(params) {
    return { ok: true, message: `‚úÖ TASKS STUB: I will soon handle: "${params.text || ''}".` };
}
// ========== Specialist: Drive (Stub for Future Expansion) ==========
function cmd_HandleDrive_(params) {
    return { ok: true, message: `‚òÅÔ∏è DRIVE STUB: I will soon handle Drive requests: "${params.text || ''}".` };
}
// ---------------------------------------------------------------------------------
// FILE: 05_MonetizationGate.ts
// PURPOSE: Handles external subscription and tier checking for the Guardian Agent.
// NOTE: This file depends on CFG_ and log_() from 01_ConfigAndUtils.ts
// ---------------------------------------------------------------------------------
/**
 * STUB: Connects to the external service/API to retrieve the user's tier
 * and their allowed services for policy enforcement.
 * * @param {string} userId The email address of the active user.
 * @returns {object} { tier: 'FREE'|'PAID_BASIC'|'PAID_PREMIUM', subscribedServices: string[] }
 */
function checkSubscriptionStatus_(userId) {
    // Log the call for future auditing
    log_('INFO', 'checkSubscriptionStatus_', { user: userId, action: 'External API Call STUB' });
    // --- STUB IMPLEMENTATION ---
    const FREE_TIER_SERVICES = ['general_chat', 'sheets'];
    if (userId.includes('premium.user')) {
        return { tier: 'PAID_PREMIUM', subscribedServices: ['calendar', 'gmail', 'tasks', 'sheets', 'general_chat', 'web_search'] };
    }
    // Default to FREE tier
    return { tier: 'FREE', subscribedServices: FREE_TIER_SERVICES };
}
/**
 * Checks if a requested service (HandlerKey) is enabled for the user's subscription tier.
 * Used by the Guardian Agent before executing a command.
 * * @param {string} userId The user's ID.
 * @param {string} handlerKey The requested service key (e.g., 'handle_calendar').
 * @returns {boolean} True if the service is enabled, false otherwise.
 */
function isServiceEnabled_(userId, handlerKey) {
    const status = checkSubscriptionStatus_(userId);
    const key = handlerKey.toLowerCase();
    if (status.tier === 'PAID_PREMIUM')
        return true;
    return status.subscribedServices.includes(key);
}
// ---------------------------------------------------------------------------------
// FILE: 06_LibraryInterface.ts
// PURPOSE: Defines the single public-facing function for the Client Project to call.
// This function implements the full execution pipeline (Router -> Guardian -> Executive).
// ---------------------------------------------------------------------------------
/**
 * Public entry point for the Polaris Client Project (Web App) via google.script.run.
 * @param {string} text The user's input query.
 * @returns {string} The final response message for the UI.
 */
function routeUserQuery(text) {
    try {
        // 1. Get the current user's ID
        const userId = Session.getActiveUser().getEmail();
        // 2. Route the query (Query 1) to determine the correct agent (Router Agent)
        const routeResult = nlpPickCommand_(text);
        log_('INFO', 'routeUserQuery_decision', {
            text: text,
            decision: routeResult.ok ? routeResult.debug : routeResult
        });
        if (!routeResult.ok) {
            log_('ERROR', 'routeUserQuery_RouteFail', { err: routeResult.reason || 'Unknown routing error' });
            const userErr = routeResult.reason === 'no-match' ? `ü§ñ Echo: ${text}` : `Router error: ${routeResult.reason}`;
            return `‚ö†Ô∏è Router Fail: ${userErr}`;
        }
        // 3. Check for subscription/policy (Guardian Agent's role)
        if (!isServiceEnabled_(userId, routeResult.handlerKey)) {
            log_('WARN', 'routeUserQuery_AccessDenied', { userId: userId, key: routeResult.handlerKey });
            return `‚ö†Ô∏è Access Denied: The **${routeResult.handlerKey}** service requires a subscription upgrade.`;
        }
        // 4. Resolve the handler function (Executive Agent's role)
        const fn = resolveHandlerFn_(routeResult.handler);
        if (!fn) {
            log_('ERROR', 'routeUserQuery_FnNotFound', { key: routeResult.handler });
            return `‚ö†Ô∏è Internal Error: Handler function not found: ${routeResult.handler}`;
        }
        // 5. Execute the specialist (Query 2)
        const out = fn({ text, userId });
        // 6. Return the result
        return (out && out.message) || JSON.stringify(out);
    }
    catch (e) {
        log_('FATAL', 'routeUserQuery_Exception', { err: e.message, stack: e.stack });
        return '‚ö†Ô∏è Critical Error: An unexpected exception occurred while processing your request.';
    }
}
/**
 * Public entry point for initial setup, callable via google.script.run or from the native editor.
 */
function setupPolarisSheets() {
    return GoogleSheets_Setup();
}
/* --- BLOCK END --- */
