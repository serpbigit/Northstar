// ========== Block#4 â€” NLP Router (Query 1 - AI Powered) ==========

// ========== TYPE DEFINITIONS ==========

interface Handler {
  key: string;
  fn: string;
  desc: string;
  fallback: string;
}

interface GetHandlersResult {
  ok: true;
  handlers: Handler[];
}

interface NlpSuccessResult {
  ok: true;
  handler: string;
  debug: { chosenKey: string };
}

interface NlpErrorResult {
  ok: false;
  reason: 'handlers-not-found' | 'router-ai-error' | 'no-match' | 'router-exception';
  err?: string;
}

type NlpResult = NlpSuccessResult | NlpErrorResult;

/**
 * Caches the handler manifest (from Handlers sheet) for 10 mins.
 */
function getHandlerManifest_(): GetHandlersResult | ErrorResult {
  try {
    const cache = CacheService.getScriptCache();
    const CACHE_KEY = 'polaris_handlers';
    const cached = cache.get(CACHE_KEY);
    if (cached) return { ok: true, handlers: JSON.parse(cached) };

    const tblResult = readTable_(CFG_.HANDLERS_SHEET);
    if (!tblResult.ok || !tblResult.rows.length) {
      return { ok: false, error: 'Handlers sheet is empty or unreadable.' };
    }

    const handlers: Handler[] = tblResult.rows.map(r => ({
      key: r.HandlerKey || r.name,
      fn: r.GAS_Function || r.fnName,
      desc: r.Description || r.description,
      fallback: r.FallbackHelpText || r.fallback
    })).filter(h => h.key && h.fn);

    if (!handlers.length) {
      return { ok: false, error: 'No valid handlers found in Handlers sheet.' };
    }

    cache.put(CACHE_KEY, JSON.stringify(handlers), 600); // Cache for 10 mins
    return { ok: true, handlers: handlers };
  } catch (e) {
    log_('ERROR', 'getHandlerManifest_', { err: (e as Error).message });
    return { ok: false, error: (e as Error).message };
  }
}

/**
 * AI-Powered Router (Query 1).
 * Uses OpenAI to pick the best specialist from the Handlers sheet.
 */
function nlpPickCommand_(text: string): NlpResult {
  try {
    const manifest = getHandlerManifest_();
    if (!manifest.ok) {
      return { ok: false, reason: 'handlers-not-found', err: manifest.error };
    }

    // Define core, built-in handlers to ensure they are always present and correctly described.
    const coreHandlers = [
      { key: 'handle_gmail', fn: 'cmd_HandleGmail_', desc: 'Use to search, read, draft, or send emails.' },
      { key: 'handle_calendar', fn: 'cmd_HandleCalendar_', desc: 'Use to create, read, or manage calendar events.' },
      { key: 'handle_sheet_data', fn: 'cmd_HandleSheetData_', desc: 'Use to add or list items in a spreadsheet list (e.g., "add milk to groceries").' },
      { key: 'general_chat', fn: 'cmd_GeneralChat_', desc: 'Use for general conversation or questions not covered by other tools.' },
      { key: 'help', fn: 'cmd_Help_', desc: 'Use to ask for help or a list of capabilities.' },
      { key: 'get_version', fn: 'cmd_GetVersion_', desc: 'Returns the current deployment version of the script.' }
    ];

    const coreHandlerKeys = new Set(coreHandlers.map(h => h.key));

    // Filter out any core handlers from the sheet to avoid duplication, allowing sheet-based overrides if needed,
    // but primarily relying on the sheet for custom/new handlers.
    const customHandlers = manifest.handlers.filter(h => !coreHandlerKeys.has(h.key));

    const allHandlersForPrompt = [...coreHandlers, ...customHandlers]; // Used for the prompt

    const toolList = allHandlersForPrompt.map(h => `HandlerKey: ${h.key}\nDescription: ${h.desc}`).join('\n---\n');

    const systemPrompt = `You are a "Query 1" router. Your ONLY job is to analyze the user's text and choose the single best HandlerKey from the provided list.
You must respond with ONLY the chosen HandlerKey and nothing else.
For example, if the user says "help me", you will respond with "help".
If no other tool is a good match for the user's request, you MUST respond with "general_chat".
Here is the list of available handlers:\n${toolList}`;

    const aiResult = callOpenAI_(systemPrompt, text);
    if (!aiResult.ok) {
      log_('ERROR', 'nlpPickCommand_AI_call', { err: aiResult.error });
      return { ok: false, reason: 'router-ai-error', err: aiResult.error };
    }

    const chosenHandlerKey = aiResult.response.trim().replace(/[."']/g, '');
    
    // Combine core and custom handlers for the final lookup.
    const allAvailableHandlers = [...coreHandlers, ...customHandlers];
    let chosenHandler = allAvailableHandlers.find(h => h.key === chosenHandlerKey);

    if (!chosenHandler) {
      log_('WARN', 'nlpPickCommand_AI_mismatch', { text: text, chosenKey: chosenHandlerKey });
      chosenHandler = allAvailableHandlers.find(h => h.key === 'general_chat');
      if (!chosenHandler) return { ok: false, reason: 'no-match' }; // Failsafe
    }

    return { ok: true, handler: chosenHandler.fn, debug: { chosenKey: chosenHandler.key } };
  } catch (e) {
    log_('ERROR', 'nlpPickCommand_', { err: (e as Error).message });
    return { ok: false, reason: 'router-exception', err: (e as Error).message };
  }
}